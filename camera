// CameraComposeActivity.kt
package com.your.package

import android.Manifest
import android.annotation.SuppressLint
import android.content.pm.PackageManager
import android.graphics.*
import android.os.Bundle
import android.util.Log
import android.util.Size
import android.view.ViewGroup
import android.widget.Toast
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.activity.result.contract.ActivityResultContracts
import androidx.camera.core.*
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material.Text
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.platform.LocalLifecycleOwner
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.viewinterop.AndroidView
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import androidx.lifecycle.LifecycleOwner
import androidx.lifecycle.lifecycleScope
import androidx.compose.ui.unit.sp
import androidx.core.graphics.toRect
import androidx.core.view.doOnLayout
import androidx.camera.view.PreviewView
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import java.io.ByteArrayOutputStream
import java.util.concurrent.Executors
import android.graphics.Point
import com.pingan.idverify.bean.IdCardType
import com.pingan.idverify.detector.PaDetectorManager
import com.pingan.idverify.bean.QualityInspectionResult
import android.content.Context
import android.util.TypedValue
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.padding
import androidx.compose.ui.unit.dp
import androidx.compose.ui.Alignment
import androidx.compose.ui.layout.onGloballyPositioned
import androidx.compose.ui.platform.LocalConfiguration
import java.nio.ByteBuffer

/**
 * 单文件：Compose + CameraX + 帧分析 + 身份证识别框（直接调用 PaDetectorManager）
 *
 * 直接复制到项目中，替换 package 为你自己的路径即可。
 *
 * 依赖（Gradle）示例：
 * implementation "androidx.camera:camera-core:1.2.3"
 * implementation "androidx.camera:camera-camera2:1.2.3"
 * implementation "androidx.camera:camera-lifecycle:1.2.3"
 * implementation "androidx.camera:camera-view:1.2.3"
 * implementation "androidx.compose.ui:ui:1.4.0"
 * implementation "androidx.activity:activity-compose:1.7.0"
 *
 * 并确保 PaDetectorManager SDK 已加入到项目中（与原 Java 工程一致）。
 */

class CameraComposeActivity : ComponentActivity() {

    private val TAG = "CameraComposeActivity"

    private val cameraExecutor = Executors.newSingleThreadExecutor()

    private val requestPermissionLauncher =
        registerForActivityResult(ActivityResultContracts.RequestPermission()) { granted ->
            if (!granted) {
                Toast.makeText(this, "Camera permission denied", Toast.LENGTH_SHORT).show()
            }
        }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // 请求相机权限（必要）
        if (ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) {
            requestPermissionLauncher.launch(Manifest.permission.CAMERA)
        }

        setContent {
            val context = LocalContext.current
            val lifecycleOwner = LocalLifecycleOwner.current

            CameraComposeScreen(
                modifier = Modifier.fillMaxSize(),
                lifecycleOwner = lifecycleOwner,
                onDetected = { bitmap, previewSize, vertices ->
                    // 在此处调用 SDK 的检测方法（与 Java 版本一致）
                    // 注意：PaDetectorManager.getIdCardType 返回某个对象（你原 Java 里是 IdCardType）
                    lifecycleScope.launch(Dispatchers.IO) {
                        try {
                            val cardType = PaDetectorManager.getIdCardType(
                                context,
                                bitmap,
                                previewSize,
                                vertices
                            )
                            Log.i(TAG, "idCardType = ${cardType.result}")
                            // 如果你需要做质量检测：
                            // val quality = PaDetectorManager.do18QualityInspection(context, bitmap, previewSize, vertices, optionParams)
                            // 然后可在主线程更新 UI
                        } catch (e: Exception) {
                            Log.e(TAG, "detect error", e)
                        }
                    }
                }
            )
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        cameraExecutor.shutdown()
    }
}

/**
 * Compose 屏（包含 PreviewView + 识别框 Overlay）
 */
@SuppressLint("UnsafeOptInUsageError")
@Composable
fun CameraComposeScreen(
    modifier: Modifier = Modifier,
    lifecycleOwner: LifecycleOwner,
    onDetected: (Bitmap, Point, Array<Point>) -> Unit
) {
    val context = LocalContext.current
    val previewView = remember { PreviewView(context) }

    val previewSizeState = remember { mutableStateOf(Point(0, 0)) }
    val verticesState = remember { mutableStateOf<Array<Point>>(arrayOf()) }
    val isLandscape = remember {
        // 简单基于配置判断屏幕方向
        val cfg = LocalConfiguration.current
        cfg.screenWidthDp > cfg.screenHeightDp
    }

    Box(modifier = modifier) {
        AndroidView(
            modifier = Modifier.fillMaxSize(),
            factory = {
                previewView.apply {
                    layoutParams = ViewGroup.LayoutParams(
                        ViewGroup.LayoutParams.MATCH_PARENT,
                        ViewGroup.LayoutParams.MATCH_PARENT
                    )
                }
            },
            update = { view ->
                view.doOnLayout {
                    val w = it.width
                    val h = it.height
                    if (w > 0 && h > 0 && (previewSizeState.value.x != w || previewSizeState.value.y != h)) {
                        previewSizeState.value = Point(w, h)
                        // 预计算识别框顶点
                        val vertices = getPhotoFrameVertices(
                            previewViewSize = previewSizeState.value,
                            isScreenLandscape = isLandscape,
                            density = context.resources.displayMetrics.density
                        )
                        verticesState.value = vertices
                    }
                }
            }
        )

        // Overlay: 画识别框和提示
        val vertices = verticesState.value
        Canvas(modifier = Modifier.fillMaxSize()) {
            if (vertices.size == 4) {
                // Draw semi-transparent mask outside rect
                val left = vertices.minOf { it.x }.toFloat()
                val top = vertices.minOf { it.y }.toFloat()
                val right = vertices.maxOf { it.x }.toFloat()
                val bottom = vertices.maxOf { it.y }.toFloat()

                // outside dim
                drawRect(color = androidx.compose.ui.graphics.Color(0x88000000), topLeft = Offset(0f, 0f), size = size)
                // carve hole
                drawRect(color = androidx.compose.ui.graphics.Color.Transparent, topLeft = Offset(left, top), size = androidx.compose.ui.geometry.Size(right - left, bottom - top))
                // frame border
                drawRect(color = Color.Green, topLeft = Offset(left, top), size = androidx.compose.ui.geometry.Size(right - left, bottom - top), style = androidx.compose.ui.graphics.drawscope.Stroke(width = 4f))
            }
        }

        // hint text
        Column(modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally) {
            Text(text = "将身份证放入框内，尽量保持平整", fontSize = 18.sp, color = androidx.compose.ui.graphics.Color.White)
        }

        // 启动 CameraX（只在 previewSize 有效时启动一次）
        val started = remember { mutableStateOf(false) }
        val previewSize = previewSizeState.value
        LaunchedEffect(previewSize.x, previewSize.y) {
            if (!started.value && previewSize.x > 0 && previewSize.y > 0) {
                started.value = true
                startCameraX(
                    context = context,
                    lifecycleOwner = lifecycleOwner,
                    previewView = previewView,
                    onFrameBitmap = { bitmap ->
                        // 每帧回调：把 bitmap、previewSize 和 vertices 传出去做 SDK 检测
                        val verts = verticesState.value
                        // guard
                        if (verts.size == 4) {
                            onDetected(bitmap, previewSize, verts)
                        }
                    }
                )
            }
        }
    }
}

/**
 * 开启 CameraX：Preview + ImageAnalysis
 */
@SuppressLint("UnsafeOptInUsageError")
private fun startCameraX(
    context: Context,
    lifecycleOwner: LifecycleOwner,
    previewView: PreviewView,
    onFrameBitmap: (Bitmap) -> Unit
) {
    val cameraProviderFuture = ProcessCameraProvider.getInstance(context)
    cameraProviderFuture.addListener({
        val cameraProvider = cameraProviderFuture.get()

        val preview = Preview.Builder()
            .build()
            .also { it.setSurfaceProvider(previewView.surfaceProvider) }

        val imageAnalysis = ImageAnalysis.Builder()
            .setTargetResolution(Size(1280, 720))
            .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)
            .build()

        val analyzerExecutor = Executors.newSingleThreadExecutor()
        imageAnalysis.setAnalyzer(analyzerExecutor) { imageProxy ->
            try {
                val bmp = imageProxyToBitmap(imageProxy)
                if (bmp != null) {
                    // 送到后台线程处理 SDK 检测（避免主线程卡顿）
                    // 这里直接在 analyzer 线程回调，SDK 若耗时较长建议内部再切线程
                    onFrameBitmap(bmp)
                }
            } catch (e: Exception) {
                Log.e("CameraX", "analyze error", e)
            } finally {
                imageProxy.close()
            }
        }

        try {
            cameraProvider.unbindAll()
            cameraProvider.bindToLifecycle(
                lifecycleOwner,
                CameraSelector.DEFAULT_BACK_CAMERA,
                preview,
                imageAnalysis
            )
        } catch (e: Exception) {
            Log.e("CameraX", "bind failed", e)
        }
    }, ContextCompat.getMainExecutor(context))
}

/**
 * 将 ImageProxy 转为 Bitmap（通过 YuvImage -> JPEG -> Bitmap 解码）
 * 兼容 YUV_420_888
 */
private fun imageProxyToBitmap(image: ImageProxy): Bitmap? {
    val format = image.format
    if (format != ImageFormat.YUV_420_888) {
        // 如果不是 YUV_420_888，尝试用 plane 0 的 buffer 直接 decode（不常见）
        try {
            val buffer = image.planes[0].buffer
            val bytes = ByteArray(buffer.remaining())
            buffer.get(bytes)
            return BitmapFactory.decodeByteArray(bytes, 0, bytes.size)
        } catch (e: Exception) {
            return null
        }
    }

    val yBuffer = image.planes[0].buffer // Y
    val uBuffer = image.planes[1].buffer // U
    val vBuffer = image.planes[2].buffer // V

    val ySize = yBuffer.remaining()
    val uSize = uBuffer.remaining()
    val vSize = vBuffer.remaining()

    val nv21 = ByteArray(ySize + uSize + vSize)

    // Y
    yBuffer.get(nv21, 0, ySize)

    // V and U are swapped in ImageProxy's planes for some devices -> convert to NV21 (Y V U)
    val chromaRowStride = image.planes[1].rowStride
    val chromaPixelStride = image.planes[1].pixelStride

    // A safe generic conversion to NV21:
    // We'll copy interleaved VU from planes 1 and 2
    var offset = ySize
    val width = image.width
    val height = image.height

    // Create temporary arrays
    val uBytes = ByteArray(uSize)
    val vBytes = ByteArray(vSize)
    uBuffer.get(uBytes)
    vBuffer.get(vBytes)

    // interleave VU
    var i = 0
    while (i < uBytes.size && offset < nv21.size) {
        nv21[offset++] = vBytes[i]
        nv21[offset++] = uBytes[i]
        i++
    }

    return try {
        val yuvImage = YuvImage(nv21, ImageFormat.NV21, width, height, null)
        val out = ByteArrayOutputStream()
        yuvImage.compressToJpeg(Rect(0, 0, width, height), 80, out)
        val imageBytes = out.toByteArray()
        BitmapFactory.decodeByteArray(imageBytes, 0, imageBytes.size)
    } catch (e: Exception) {
        Log.e("imageProxyToBitmap", "convert fail", e)
        null
    }
}

/**
 * 复刻自你 Java 里 getPhotoFrameVertices 的算法
 * 返回顺序： 左上, 右上, 右下, 左下
 *
 * previewViewSize: 传入 PreviewView 的像素尺寸 (Point)
 * isScreenLandscape: 屏幕是否横向
 * density: 屏幕 density（用于 dp->px）
 */
fun getPhotoFrameVertices(previewViewSize: Point, isScreenLandscape: Boolean, density: Float): Array<Point> {
    val SCREEN_RECT_WIDTH_FINAL_PORTRAIT = 340
    val SCREEN_RECT_WIDTH_FINAL_LANDSCAPE = 430
    val SCREEN_RECT_HEIGHT_FINAL_PORTRAIT = 215
    val SCREEN_RECT_HEIGHT_FINAL_LANDSCAPE = 272

    val photoFrameWidthTop = if (isScreenLandscape) SCREEN_RECT_WIDTH_FINAL_LANDSCAPE else SCREEN_RECT_WIDTH_FINAL_PORTRAIT
    val photoFrameWidthBottom = photoFrameWidthTop
    val photoFrameHeight = if (isScreenLandscape) SCREEN_RECT_HEIGHT_FINAL_LANDSCAPE else SCREEN_RECT_HEIGHT_FINAL_PORTRAIT

    val frameWidthPx = dpToPx(photoFrameWidthTop.toFloat(), density).toInt()
    val frameHeightPx = dpToPx(photoFrameHeight.toFloat(), density).toInt()

    val previewWidth = previewViewSize.x
    val previewHeight = if (isScreenLandscape) previewViewSize.y else previewViewSize.y * 9 / 10

    val x1 = previewWidth / 2 - frameWidthPx / 2
    val y1 = previewHeight / 2 - frameHeightPx / 2

    val x2 = previewWidth / 2 + frameWidthPx / 2
    val y2 = y1

    val x3 = x2
    val y3 = previewHeight / 2 + frameHeightPx / 2

    val x4 = x1
    val y4 = y3

    return arrayOf(Point(x1, y1), Point(x2, y2), Point(x3, y3), Point(x4, y4))
}

/**
 * dp -> px（兼容）
 */
fun dpToPx(dp: Float, density: Float): Float {
    return dp * density
}
